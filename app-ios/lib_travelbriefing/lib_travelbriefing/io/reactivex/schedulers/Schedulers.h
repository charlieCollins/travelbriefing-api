//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/io/reactivex/schedulers/Schedulers.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexSchedulersSchedulers")
#ifdef RESTRICT_IoReactivexSchedulersSchedulers
#define INCLUDE_ALL_IoReactivexSchedulersSchedulers 0
#else
#define INCLUDE_ALL_IoReactivexSchedulersSchedulers 1
#endif
#undef RESTRICT_IoReactivexSchedulersSchedulers

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexSchedulersSchedulers_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers))
#define IoReactivexSchedulersSchedulers_

@class IoReactivexScheduler;
@protocol JavaUtilConcurrentExecutor;

@interface IoReactivexSchedulersSchedulers : NSObject

#pragma mark Public

+ (IoReactivexScheduler *)computation;

+ (IoReactivexScheduler *)fromWithJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor;

+ (IoReactivexScheduler *)io;

+ (IoReactivexScheduler *)newThread OBJC_METHOD_FAMILY_NONE;

+ (void)shutdown;

+ (IoReactivexScheduler *)single;

+ (void)start;

+ (IoReactivexScheduler *)trampoline;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_SINGLE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_SINGLE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, SINGLE, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_COMPUTATION();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_COMPUTATION;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, COMPUTATION, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_IO();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_IO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, IO, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_TRAMPOLINE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_TRAMPOLINE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, TRAMPOLINE, IoReactivexScheduler *)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_get_NEW_THREAD();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_NEW_THREAD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers, NEW_THREAD, IoReactivexScheduler *)

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_computation();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_io();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_trampoline();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_newThread();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_single();

FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_fromWithJavaUtilConcurrentExecutor_(id<JavaUtilConcurrentExecutor> executor);

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_shutdown();

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_start();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers)

#endif

#if !defined (IoReactivexSchedulersSchedulers_SingleHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_SingleHolder))
#define IoReactivexSchedulersSchedulers_SingleHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_SingleHolder : NSObject

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_SingleHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_SingleHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_SingleHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_SingleHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_SingleHolder_init(IoReactivexSchedulersSchedulers_SingleHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleHolder *new_IoReactivexSchedulersSchedulers_SingleHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_SingleHolder *create_IoReactivexSchedulersSchedulers_SingleHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_SingleHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_ComputationHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_ComputationHolder))
#define IoReactivexSchedulersSchedulers_ComputationHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_ComputationHolder : NSObject

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_ComputationHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_ComputationHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_ComputationHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_ComputationHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_ComputationHolder_init(IoReactivexSchedulersSchedulers_ComputationHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationHolder *new_IoReactivexSchedulersSchedulers_ComputationHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_ComputationHolder *create_IoReactivexSchedulersSchedulers_ComputationHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_ComputationHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_IoHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_IoHolder))
#define IoReactivexSchedulersSchedulers_IoHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_IoHolder : NSObject

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_IoHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_IoHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_IoHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_IoHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_IoHolder_init(IoReactivexSchedulersSchedulers_IoHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IoHolder *new_IoReactivexSchedulersSchedulers_IoHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_IoHolder *create_IoReactivexSchedulersSchedulers_IoHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_IoHolder)

#endif

#if !defined (IoReactivexSchedulersSchedulers_NewThreadHolder_) && (INCLUDE_ALL_IoReactivexSchedulersSchedulers || defined(INCLUDE_IoReactivexSchedulersSchedulers_NewThreadHolder))
#define IoReactivexSchedulersSchedulers_NewThreadHolder_

@class IoReactivexScheduler;

@interface IoReactivexSchedulersSchedulers_NewThreadHolder : NSObject

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_STATIC_INIT(IoReactivexSchedulersSchedulers_NewThreadHolder)

inline IoReactivexScheduler *IoReactivexSchedulersSchedulers_NewThreadHolder_get_DEFAULT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IoReactivexScheduler *IoReactivexSchedulersSchedulers_NewThreadHolder_DEFAULT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexSchedulersSchedulers_NewThreadHolder, DEFAULT, IoReactivexScheduler *)

FOUNDATION_EXPORT void IoReactivexSchedulersSchedulers_NewThreadHolder_init(IoReactivexSchedulersSchedulers_NewThreadHolder *self);

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadHolder *new_IoReactivexSchedulersSchedulers_NewThreadHolder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexSchedulersSchedulers_NewThreadHolder *create_IoReactivexSchedulersSchedulers_NewThreadHolder_init();

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexSchedulersSchedulers_NewThreadHolder)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexSchedulersSchedulers")
