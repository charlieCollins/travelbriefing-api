//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/okio/Pipe.java
//

#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "okio/Buffer.h"
#include "okio/Pipe.h"
#include "okio/Sink.h"
#include "okio/Source.h"
#include "okio/Timeout.h"

@interface OkioPipe () {
 @public
  id<OkioSink> sink_;
  id<OkioSource> source_;
}

@end

J2OBJC_FIELD_SETTER(OkioPipe, sink_, id<OkioSink>)
J2OBJC_FIELD_SETTER(OkioPipe, source_, id<OkioSource>)

@interface OkioPipe_PipeSink () {
 @public
  OkioPipe *this$0_;
}

@end

@interface OkioPipe_PipeSource () {
 @public
  OkioPipe *this$0_;
}

@end

@implementation OkioPipe

- (instancetype)initWithLong:(jlong)maxBufferSize {
  OkioPipe_initWithLong_(self, maxBufferSize);
  return self;
}

- (id<OkioSource>)source {
  return source_;
}

- (id<OkioSink>)sink {
  return sink_;
}

- (void)dealloc {
  RELEASE_(buffer_);
  RELEASE_(sink_);
  RELEASE_(source_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LOkioSource;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioSink;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithLong:);
  methods[1].selector = @selector(source);
  methods[2].selector = @selector(sink);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "maxBufferSize_", "J", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "buffer_", "LOkioBuffer;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "sinkClosed_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sourceClosed_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "sink_", "LOkioSink;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "source_", "LOkioSource;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "J", "LOkioPipe_PipeSink;LOkioPipe_PipeSource;" };
  static const J2ObjcClassInfo _OkioPipe = { "Pipe", "okio", ptrTable, methods, fields, 7, 0x11, 3, 6, -1, 1, -1, -1, -1 };
  return &_OkioPipe;
}

@end

void OkioPipe_initWithLong_(OkioPipe *self, jlong maxBufferSize) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->buffer_, new_OkioBuffer_init());
  JreStrongAssignAndConsume(&self->sink_, new_OkioPipe_PipeSink_initWithOkioPipe_(self));
  JreStrongAssignAndConsume(&self->source_, new_OkioPipe_PipeSource_initWithOkioPipe_(self));
  if (maxBufferSize < 1LL) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"maxBufferSize < 1: ", maxBufferSize));
  }
  self->maxBufferSize_ = maxBufferSize;
}

OkioPipe *new_OkioPipe_initWithLong_(jlong maxBufferSize) {
  J2OBJC_NEW_IMPL(OkioPipe, initWithLong_, maxBufferSize)
}

OkioPipe *create_OkioPipe_initWithLong_(jlong maxBufferSize) {
  J2OBJC_CREATE_IMPL(OkioPipe, initWithLong_, maxBufferSize)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioPipe)

@implementation OkioPipe_PipeSink

- (instancetype)initWithOkioPipe:(OkioPipe *)outer$ {
  OkioPipe_PipeSink_initWithOkioPipe_(self, outer$);
  return self;
}

- (void)writeWithOkioBuffer:(OkioBuffer *)source
                   withLong:(jlong)byteCount {
  @synchronized(this$0_->buffer_) {
    if (this$0_->sinkClosed_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"closed");
    while (byteCount > 0) {
      if (this$0_->sourceClosed_) @throw create_JavaIoIOException_initWithNSString_(@"source is closed");
      jlong bufferSpaceAvailable = this$0_->maxBufferSize_ - [((OkioBuffer *) nil_chk(this$0_->buffer_)) size];
      if (bufferSpaceAvailable == 0) {
        [((OkioTimeout *) nil_chk(timeout_)) waitUntilNotifiedWithId:this$0_->buffer_];
        continue;
      }
      jlong bytesToWrite = JavaLangMath_minWithLong_withLong_(bufferSpaceAvailable, byteCount);
      [this$0_->buffer_ writeWithOkioBuffer:source withLong:bytesToWrite];
      byteCount -= bytesToWrite;
      [this$0_->buffer_ java_notifyAll];
    }
  }
}

- (void)flush {
  @synchronized(this$0_->buffer_) {
    if (this$0_->sinkClosed_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"closed");
    while ([((OkioBuffer *) nil_chk(this$0_->buffer_)) size] > 0) {
      if (this$0_->sourceClosed_) @throw create_JavaIoIOException_initWithNSString_(@"source is closed");
      [((OkioTimeout *) nil_chk(timeout_)) waitUntilNotifiedWithId:this$0_->buffer_];
    }
  }
}

- (void)close {
  @synchronized(this$0_->buffer_) {
    if (this$0_->sinkClosed_) return;
    @try {
      [self flush];
    }
    @finally {
      this$0_->sinkClosed_ = true;
      [((OkioBuffer *) nil_chk(this$0_->buffer_)) java_notifyAll];
    }
  }
}

- (OkioTimeout *)timeout {
  return timeout_;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(timeout_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 2, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 2, -1, -1, -1 },
    { NULL, "LOkioTimeout;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOkioPipe:);
  methods[1].selector = @selector(writeWithOkioBuffer:withLong:);
  methods[2].selector = @selector(flush);
  methods[3].selector = @selector(close);
  methods[4].selector = @selector(timeout);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LOkioPipe;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "timeout_", "LOkioTimeout;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "write", "LOkioBuffer;J", "LJavaIoIOException;", "LOkioPipe;" };
  static const J2ObjcClassInfo _OkioPipe_PipeSink = { "PipeSink", "okio", ptrTable, methods, fields, 7, 0x10, 5, 2, 3, -1, -1, -1, -1 };
  return &_OkioPipe_PipeSink;
}

@end

void OkioPipe_PipeSink_initWithOkioPipe_(OkioPipe_PipeSink *self, OkioPipe *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->timeout_, new_OkioTimeout_init());
}

OkioPipe_PipeSink *new_OkioPipe_PipeSink_initWithOkioPipe_(OkioPipe *outer$) {
  J2OBJC_NEW_IMPL(OkioPipe_PipeSink, initWithOkioPipe_, outer$)
}

OkioPipe_PipeSink *create_OkioPipe_PipeSink_initWithOkioPipe_(OkioPipe *outer$) {
  J2OBJC_CREATE_IMPL(OkioPipe_PipeSink, initWithOkioPipe_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioPipe_PipeSink)

@implementation OkioPipe_PipeSource

- (instancetype)initWithOkioPipe:(OkioPipe *)outer$ {
  OkioPipe_PipeSource_initWithOkioPipe_(self, outer$);
  return self;
}

- (jlong)readWithOkioBuffer:(OkioBuffer *)sink
                   withLong:(jlong)byteCount {
  @synchronized(this$0_->buffer_) {
    if (this$0_->sourceClosed_) @throw create_JavaLangIllegalStateException_initWithNSString_(@"closed");
    while ([((OkioBuffer *) nil_chk(this$0_->buffer_)) size] == 0) {
      if (this$0_->sinkClosed_) return -1LL;
      [((OkioTimeout *) nil_chk(timeout_)) waitUntilNotifiedWithId:this$0_->buffer_];
    }
    jlong result = [this$0_->buffer_ readWithOkioBuffer:sink withLong:byteCount];
    [this$0_->buffer_ java_notifyAll];
    return result;
  }
}

- (void)close {
  @synchronized(this$0_->buffer_) {
    this$0_->sourceClosed_ = true;
    [((OkioBuffer *) nil_chk(this$0_->buffer_)) java_notifyAll];
  }
}

- (OkioTimeout *)timeout {
  return timeout_;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(timeout_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 2, -1, -1, -1 },
    { NULL, "LOkioTimeout;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOkioPipe:);
  methods[1].selector = @selector(readWithOkioBuffer:withLong:);
  methods[2].selector = @selector(close);
  methods[3].selector = @selector(timeout);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LOkioPipe;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "timeout_", "LOkioTimeout;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "read", "LOkioBuffer;J", "LJavaIoIOException;", "LOkioPipe;" };
  static const J2ObjcClassInfo _OkioPipe_PipeSource = { "PipeSource", "okio", ptrTable, methods, fields, 7, 0x10, 4, 2, 3, -1, -1, -1, -1 };
  return &_OkioPipe_PipeSource;
}

@end

void OkioPipe_PipeSource_initWithOkioPipe_(OkioPipe_PipeSource *self, OkioPipe *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->timeout_, new_OkioTimeout_init());
}

OkioPipe_PipeSource *new_OkioPipe_PipeSource_initWithOkioPipe_(OkioPipe *outer$) {
  J2OBJC_NEW_IMPL(OkioPipe_PipeSource, initWithOkioPipe_, outer$)
}

OkioPipe_PipeSource *create_OkioPipe_PipeSource_initWithOkioPipe_(OkioPipe *outer$) {
  J2OBJC_CREATE_IMPL(OkioPipe_PipeSource, initWithOkioPipe_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioPipe_PipeSource)
