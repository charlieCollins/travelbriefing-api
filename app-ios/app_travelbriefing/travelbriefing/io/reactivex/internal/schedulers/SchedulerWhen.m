//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/io/reactivex/internal/schedulers/SchedulerWhen.java
//

#include "J2ObjC_source.h"
#include "io/reactivex/Completable.h"
#include "io/reactivex/CompletableObserver.h"
#include "io/reactivex/Flowable.h"
#include "io/reactivex/Scheduler.h"
#include "io/reactivex/disposables/Disposable.h"
#include "io/reactivex/disposables/Disposables.h"
#include "io/reactivex/exceptions/Exceptions.h"
#include "io/reactivex/functions/Function.h"
#include "io/reactivex/internal/schedulers/SchedulerWhen.h"
#include "io/reactivex/processors/FlowableProcessor.h"
#include "io/reactivex/processors/UnicastProcessor.h"
#include "java/lang/Runnable.h"
#include "java/lang/RuntimeException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

#pragma clang diagnostic ignored "-Wincomplete-implementation"

@interface IoReactivexInternalSchedulersSchedulerWhen () {
 @public
  IoReactivexScheduler *actualScheduler_;
  IoReactivexProcessorsFlowableProcessor *workerProcessor_;
  id<IoReactivexDisposablesDisposable> disposable_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, actualScheduler_, IoReactivexScheduler *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, workerProcessor_, IoReactivexProcessorsFlowableProcessor *)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen, disposable_, id<IoReactivexDisposablesDisposable>)

@interface IoReactivexInternalSchedulersSchedulerWhen_1 : NSObject < IoReactivexFunctionsFunction > {
 @public
  IoReactivexScheduler_Worker *val$actualWorker_;
}

- (instancetype)initWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)capture$0;

- (IoReactivexCompletable *)applyWithId:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_1)

__attribute__((unused)) static void IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_1 *self, IoReactivexScheduler_Worker *capture$0);

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_1 *new_IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_1 *create_IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *capture$0);

@interface IoReactivexInternalSchedulersSchedulerWhen_1_1 : IoReactivexCompletable {
 @public
  IoReactivexInternalSchedulersSchedulerWhen_1 *this$0_;
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *val$action_;
}

- (instancetype)initWithIoReactivexInternalSchedulersSchedulerWhen_1:(IoReactivexInternalSchedulersSchedulerWhen_1 *)outer$
      withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)capture$0;

- (void)subscribeActualWithIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_1_1)

__attribute__((unused)) static void IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1_1 *self, IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0);

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_1_1 *new_IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_1_1 *create_IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0);

@interface IoReactivexInternalSchedulersSchedulerWhen_2 : IoReactivexScheduler_Worker {
 @public
  IoReactivexProcessorsFlowableProcessor *val$actionProcessor_;
  IoReactivexScheduler_Worker *val$actualWorker_;
  JavaUtilConcurrentAtomicAtomicBoolean *unsubscribed_;
}

- (instancetype)initWithIoReactivexProcessorsFlowableProcessor:(IoReactivexProcessorsFlowableProcessor *)capture$0
                               withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)capture$1;

- (void)dispose;

- (jboolean)isDisposed;

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                                            withLong:(jlong)delayTime
                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)action;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_2)

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_2, unsubscribed_, JavaUtilConcurrentAtomicAtomicBoolean *)

__attribute__((unused)) static void IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_2 *self, IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1);

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_2 *new_IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1) NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_2 *create_IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1);

@interface IoReactivexInternalSchedulersSchedulerWhen_3 : NSObject < IoReactivexDisposablesDisposable >

- (instancetype)init;

- (void)dispose;

- (jboolean)isDisposed;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_3)

__attribute__((unused)) static void IoReactivexInternalSchedulersSchedulerWhen_3_init(IoReactivexInternalSchedulersSchedulerWhen_3 *self);

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_3 *new_IoReactivexInternalSchedulersSchedulerWhen_3_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static IoReactivexInternalSchedulersSchedulerWhen_3 *create_IoReactivexInternalSchedulersSchedulerWhen_3_init();

@interface IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction () {
 @public
  id<JavaLangRunnable> action_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, action_, id<JavaLangRunnable>)

@interface IoReactivexInternalSchedulersSchedulerWhen_DelayedAction () {
 @public
  id<JavaLangRunnable> action_;
  jlong delayTime_;
  JavaUtilConcurrentTimeUnit *unit_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, action_, id<JavaLangRunnable>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, unit_, JavaUtilConcurrentTimeUnit *)

@interface IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction () {
 @public
  id<IoReactivexCompletableObserver> actionCompletable_;
  id<JavaLangRunnable> action_;
}

@end

J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, actionCompletable_, id<IoReactivexCompletableObserver>)
J2OBJC_FIELD_SETTER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, action_, id<JavaLangRunnable>)

J2OBJC_INITIALIZED_DEFN(IoReactivexInternalSchedulersSchedulerWhen)

id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED;
id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_DISPOSED;

@implementation IoReactivexInternalSchedulersSchedulerWhen

- (instancetype)initWithIoReactivexFunctionsFunction:(id<IoReactivexFunctionsFunction>)combine
                            withIoReactivexScheduler:(IoReactivexScheduler *)actualScheduler {
  IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(self, combine, actualScheduler);
  return self;
}

- (void)dispose {
  [((id<IoReactivexDisposablesDisposable>) nil_chk(disposable_)) dispose];
}

- (jboolean)isDisposed {
  return [((id<IoReactivexDisposablesDisposable>) nil_chk(disposable_)) isDisposed];
}

- (IoReactivexScheduler_Worker *)createWorker {
  IoReactivexScheduler_Worker *actualWorker = [((IoReactivexScheduler *) nil_chk(actualScheduler_)) createWorker];
  IoReactivexProcessorsFlowableProcessor *actionProcessor = [((IoReactivexProcessorsUnicastProcessor *) nil_chk(IoReactivexProcessorsUnicastProcessor_create())) toSerialized];
  IoReactivexFlowable *actions = [((IoReactivexProcessorsFlowableProcessor *) nil_chk(actionProcessor)) mapWithIoReactivexFunctionsFunction:create_IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(actualWorker)];
  IoReactivexScheduler_Worker *worker = create_IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(actionProcessor, actualWorker);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(workerProcessor_)) onNextWithId:actions];
  return worker;
}

- (void)dealloc {
  RELEASE_(actualScheduler_);
  RELEASE_(workerProcessor_);
  RELEASE_(disposable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexFunctionsFunction:withIoReactivexScheduler:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(createWorker);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "actualScheduler_", "LIoReactivexScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "workerProcessor_", "LIoReactivexProcessorsFlowableProcessor;", .constantValue.asLong = 0, 0x12, -1, -1, 2, -1 },
    { "disposable_", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "SUBSCRIBED", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x18, -1, 3, -1, -1 },
    { "DISPOSED", "LIoReactivexDisposablesDisposable;", .constantValue.asLong = 0, 0x18, -1, 4, -1, -1 },
  };
  static const void *ptrTable[] = { "LIoReactivexFunctionsFunction;LIoReactivexScheduler;", "(Lio/reactivex/functions/Function<Lio/reactivex/Flowable<Lio/reactivex/Flowable<Lio/reactivex/Completable;>;>;Lio/reactivex/Completable;>;Lio/reactivex/Scheduler;)V", "Lio/reactivex/processors/FlowableProcessor<Lio/reactivex/Flowable<Lio/reactivex/Completable;>;>;", &IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED, &IoReactivexInternalSchedulersSchedulerWhen_DISPOSED, "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;LIoReactivexInternalSchedulersSchedulerWhen_ImmediateAction;LIoReactivexInternalSchedulersSchedulerWhen_DelayedAction;LIoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen = { "SchedulerWhen", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x1, 4, 5, -1, 5, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen;
}

+ (void)initialize {
  if (self == [IoReactivexInternalSchedulersSchedulerWhen class]) {
    JreStrongAssignAndConsume(&IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED, new_IoReactivexInternalSchedulersSchedulerWhen_3_init());
    JreStrongAssign(&IoReactivexInternalSchedulersSchedulerWhen_DISPOSED, IoReactivexDisposablesDisposables_disposed());
    J2OBJC_SET_INITIALIZED(IoReactivexInternalSchedulersSchedulerWhen)
  }
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(IoReactivexInternalSchedulersSchedulerWhen *self, id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  IoReactivexScheduler_init(self);
  JreStrongAssign(&self->actualScheduler_, actualScheduler);
  JreStrongAssign(&self->workerProcessor_, [((IoReactivexProcessorsUnicastProcessor *) nil_chk(IoReactivexProcessorsUnicastProcessor_create())) toSerialized]);
  @try {
    JreStrongAssign(&self->disposable_, [((IoReactivexCompletable *) nil_chk([((id<IoReactivexFunctionsFunction>) nil_chk(combine)) applyWithId:self->workerProcessor_])) subscribe]);
  }
  @catch (NSException *e) {
    IoReactivexExceptionsExceptions_propagateWithNSException_(e);
  }
}

IoReactivexInternalSchedulersSchedulerWhen *new_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen, initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_, combine, actualScheduler)
}

IoReactivexInternalSchedulersSchedulerWhen *create_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen, initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_, combine, actualScheduler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen)

@implementation IoReactivexInternalSchedulersSchedulerWhen_1

- (instancetype)initWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)capture$0 {
  IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(self, capture$0);
  return self;
}

- (IoReactivexCompletable *)applyWithId:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)action {
  return create_IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(self, action);
}

- (void)dealloc {
  RELEASE_(val$actualWorker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexCompletable;", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(applyWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$actualWorker_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "apply", "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;", "LIoReactivexInternalSchedulersSchedulerWhen;", "createWorker", "Ljava/lang/Object;Lio/reactivex/functions/Function<Lio/reactivex/internal/schedulers/SchedulerWhen$ScheduledAction;Lio/reactivex/Completable;>;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_1 = { "", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8018, 2, 1, 2, -1, 3, 4, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_1;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_1 *self, IoReactivexScheduler_Worker *capture$0) {
  JreStrongAssign(&self->val$actualWorker_, capture$0);
  NSObject_init(self);
}

IoReactivexInternalSchedulersSchedulerWhen_1 *new_IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *capture$0) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_1, initWithIoReactivexScheduler_Worker_, capture$0)
}

IoReactivexInternalSchedulersSchedulerWhen_1 *create_IoReactivexInternalSchedulersSchedulerWhen_1_initWithIoReactivexScheduler_Worker_(IoReactivexScheduler_Worker *capture$0) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_1, initWithIoReactivexScheduler_Worker_, capture$0)
}

@implementation IoReactivexInternalSchedulersSchedulerWhen_1_1

- (instancetype)initWithIoReactivexInternalSchedulersSchedulerWhen_1:(IoReactivexInternalSchedulersSchedulerWhen_1 *)outer$
      withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *)capture$0 {
  IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(self, outer$, capture$0);
  return self;
}

- (void)subscribeActualWithIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  [((id<IoReactivexCompletableObserver>) nil_chk(actionCompletable)) onSubscribeWithIoReactivexDisposablesDisposable:val$action_];
  [((IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *) nil_chk(val$action_)) callWithIoReactivexScheduler_Worker:this$0_->val$actualWorker_ withIoReactivexCompletableObserver:actionCompletable];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexInternalSchedulersSchedulerWhen_1:withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction:);
  methods[1].selector = @selector(subscribeActualWithIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LIoReactivexInternalSchedulersSchedulerWhen_1;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$action_", "LIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "subscribeActual", "LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen_1;", "applyWithId:" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_1_1 = { "", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8018, 2, 2, 2, -1, 3, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_1_1;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1_1 *self, IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$action_, capture$0);
  IoReactivexCompletable_init(self);
}

IoReactivexInternalSchedulersSchedulerWhen_1_1 *new_IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_1_1, initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_, outer$, capture$0)
}

IoReactivexInternalSchedulersSchedulerWhen_1_1 *create_IoReactivexInternalSchedulersSchedulerWhen_1_1_initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_(IoReactivexInternalSchedulersSchedulerWhen_1 *outer$, IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *capture$0) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_1_1, initWithIoReactivexInternalSchedulersSchedulerWhen_1_withIoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_, outer$, capture$0)
}

@implementation IoReactivexInternalSchedulersSchedulerWhen_2

- (instancetype)initWithIoReactivexProcessorsFlowableProcessor:(IoReactivexProcessorsFlowableProcessor *)capture$0
                               withIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)capture$1 {
  IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(self, capture$0, capture$1);
  return self;
}

- (void)dispose {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(unsubscribed_)) compareAndSetWithBoolean:false withBoolean:true]) {
    [((IoReactivexProcessorsFlowableProcessor *) nil_chk(val$actionProcessor_)) onComplete];
    [((IoReactivexScheduler_Worker *) nil_chk(val$actualWorker_)) dispose];
  }
}

- (jboolean)isDisposed {
  return [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(unsubscribed_)) get];
}

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                                            withLong:(jlong)delayTime
                                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *delayedAction = create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(action, delayTime, unit);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(val$actionProcessor_)) onNextWithId:delayedAction];
  return delayedAction;
}

- (id<IoReactivexDisposablesDisposable>)scheduleWithJavaLangRunnable:(id<JavaLangRunnable>)action {
  IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *immediateAction = create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(action);
  [((IoReactivexProcessorsFlowableProcessor *) nil_chk(val$actionProcessor_)) onNextWithId:immediateAction];
  return immediateAction;
}

- (void)dealloc {
  RELEASE_(val$actionProcessor_);
  RELEASE_(val$actualWorker_);
  RELEASE_(unsubscribed_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x1, 0, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithIoReactivexProcessorsFlowableProcessor:withIoReactivexScheduler_Worker:);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  methods[3].selector = @selector(scheduleWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[4].selector = @selector(scheduleWithJavaLangRunnable:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$actionProcessor_", "LIoReactivexProcessorsFlowableProcessor;", .constantValue.asLong = 0, 0x1012, -1, -1, 3, -1 },
    { "val$actualWorker_", "LIoReactivexScheduler_Worker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "unsubscribed_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "schedule", "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "LJavaLangRunnable;", "Lio/reactivex/processors/FlowableProcessor<Lio/reactivex/internal/schedulers/SchedulerWhen$ScheduledAction;>;", "LIoReactivexInternalSchedulersSchedulerWhen;", "createWorker" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_2 = { "", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8018, 5, 3, 4, -1, 5, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_2;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexInternalSchedulersSchedulerWhen_2 *self, IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1) {
  JreStrongAssign(&self->val$actionProcessor_, capture$0);
  JreStrongAssign(&self->val$actualWorker_, capture$1);
  IoReactivexScheduler_Worker_init(self);
  JreStrongAssignAndConsume(&self->unsubscribed_, new_JavaUtilConcurrentAtomicAtomicBoolean_init());
}

IoReactivexInternalSchedulersSchedulerWhen_2 *new_IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_2, initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_, capture$0, capture$1)
}

IoReactivexInternalSchedulersSchedulerWhen_2 *create_IoReactivexInternalSchedulersSchedulerWhen_2_initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_(IoReactivexProcessorsFlowableProcessor *capture$0, IoReactivexScheduler_Worker *capture$1) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_2, initWithIoReactivexProcessorsFlowableProcessor_withIoReactivexScheduler_Worker_, capture$0, capture$1)
}

@implementation IoReactivexInternalSchedulersSchedulerWhen_3

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersSchedulerWhen_3_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dispose {
}

- (jboolean)isDisposed {
  return false;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(dispose);
  methods[2].selector = @selector(isDisposed);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_3 = { "", "io.reactivex.internal.schedulers", ptrTable, methods, NULL, 7, 0x8018, 3, 0, 0, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_3;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_3_init(IoReactivexInternalSchedulersSchedulerWhen_3 *self) {
  NSObject_init(self);
}

IoReactivexInternalSchedulersSchedulerWhen_3 *new_IoReactivexInternalSchedulersSchedulerWhen_3_init() {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_3, init)
}

IoReactivexInternalSchedulersSchedulerWhen_3 *create_IoReactivexInternalSchedulersSchedulerWhen_3_init() {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_3, init)
}

@implementation IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)callWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
         withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  id<IoReactivexDisposablesDisposable> oldState = [self get];
  if (oldState == JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED)) {
    return;
  }
  if (oldState != JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED)) {
    return;
  }
  id<IoReactivexDisposablesDisposable> newState = [self callActualWithIoReactivexScheduler_Worker:actualWorker withIoReactivexCompletableObserver:actionCompletable];
  if (![self compareAndSetWithId:JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED) withId:newState]) {
    [((id<IoReactivexDisposablesDisposable>) nil_chk(newState)) dispose];
  }
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)isDisposed {
  return [((id<IoReactivexDisposablesDisposable>) nil_chk([self get])) isDisposed];
}

- (void)dispose {
  id<IoReactivexDisposablesDisposable> oldState;
  id<IoReactivexDisposablesDisposable> newState = JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED);
  do {
    oldState = [self get];
    if (oldState == JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED)) {
      return;
    }
  }
  while (![self compareAndSetWithId:oldState withId:newState]);
  if (oldState != JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED)) {
    [((id<IoReactivexDisposablesDisposable>) nil_chk(oldState)) dispose];
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 0, 1, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x404, 2, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(callWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  methods[2].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  methods[3].selector = @selector(isDisposed);
  methods[4].selector = @selector(dispose);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "call", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "callActual", "LIoReactivexInternalSchedulersSchedulerWhen;", "Ljava/util/concurrent/atomic/AtomicReference<Lio/reactivex/disposables/Disposable;>;Lio/reactivex/disposables/Disposable;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction = { "ScheduledAction", "io.reactivex.internal.schedulers", ptrTable, methods, NULL, 7, 0x408, 5, 0, 3, -1, -1, 4, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *self) {
  JavaUtilConcurrentAtomicAtomicReference_initWithId_(self, JreLoadStatic(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action {
  IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(self, action);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  return [((IoReactivexScheduler_Worker *) nil_chk(actualWorker)) scheduleWithJavaLangRunnable:create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(action_, actionCompletable)];
}

- (void)dealloc {
  RELEASE_(action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x4, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:);
  methods[1].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;", "callActual", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction = { "ImmediateAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 1, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *self, id<JavaLangRunnable> action) {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  JreStrongAssign(&self->action_, action);
}

IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *new_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, initWithJavaLangRunnable_, action)
}

IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction, initWithJavaLangRunnable_, action)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_DelayedAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                withLong:(jlong)delayTime
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(self, action, delayTime, unit);
  return self;
}

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  return [((IoReactivexScheduler_Worker *) nil_chk(actualWorker)) scheduleWithJavaLangRunnable:create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(action_, actionCompletable) withLong:delayTime_ withJavaUtilConcurrentTimeUnit:unit_];
}

- (void)dealloc {
  RELEASE_(action_);
  RELEASE_(unit_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LIoReactivexDisposablesDisposable;", 0x4, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[1].selector = @selector(callActualWithIoReactivexScheduler_Worker:withIoReactivexCompletableObserver:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "delayTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "unit_", "LJavaUtilConcurrentTimeUnit;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;JLJavaUtilConcurrentTimeUnit;", "callActual", "LIoReactivexScheduler_Worker;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_DelayedAction = { "DelayedAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 3, 3, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *self, id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(self);
  JreStrongAssign(&self->action_, action);
  self->delayTime_ = delayTime;
  JreStrongAssign(&self->unit_, unit);
}

IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *new_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_, action, delayTime, unit)
}

IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction, initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_, action, delayTime, unit)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

@implementation IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
      withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable {
  IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(self, action, actionCompletable);
  return self;
}

- (void)run {
  @try {
    [((id<JavaLangRunnable>) nil_chk(action_)) run];
  }
  @finally {
    [((id<IoReactivexCompletableObserver>) nil_chk(actionCompletable_)) onComplete];
  }
}

- (void)dealloc {
  RELEASE_(actionCompletable_);
  RELEASE_(action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaLangRunnable:withIoReactivexCompletableObserver:);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "actionCompletable_", "LIoReactivexCompletableObserver;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "action_", "LJavaLangRunnable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaLangRunnable;LIoReactivexCompletableObserver;", "LIoReactivexInternalSchedulersSchedulerWhen;" };
  static const J2ObjcClassInfo _IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction = { "OnCompletedAction", "io.reactivex.internal.schedulers", ptrTable, methods, fields, 7, 0x8, 2, 2, 1, -1, -1, -1, -1 };
  return &_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction;
}

@end

void IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *self, id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  NSObject_init(self);
  JreStrongAssign(&self->action_, action);
  JreStrongAssign(&self->actionCompletable_, actionCompletable);
}

IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *new_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  J2OBJC_NEW_IMPL(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, initWithJavaLangRunnable_withIoReactivexCompletableObserver_, action, actionCompletable)
}

IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) {
  J2OBJC_CREATE_IMPL(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction, initWithJavaLangRunnable_withIoReactivexCompletableObserver_, action, actionCompletable)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)
