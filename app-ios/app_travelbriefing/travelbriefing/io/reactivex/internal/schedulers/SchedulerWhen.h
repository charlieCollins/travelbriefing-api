//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/io/reactivex/internal/schedulers/SchedulerWhen.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen")
#ifdef RESTRICT_IoReactivexInternalSchedulersSchedulerWhen
#define INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen 0
#else
#define INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen 1
#endif
#undef RESTRICT_IoReactivexInternalSchedulersSchedulerWhen
#ifdef INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction
#define INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction 1
#endif
#ifdef INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction
#define INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction 1
#endif

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen))
#define IoReactivexInternalSchedulersSchedulerWhen_

#define RESTRICT_IoReactivexScheduler 1
#define INCLUDE_IoReactivexScheduler 1
#include "io/reactivex/Scheduler.h"

#define RESTRICT_IoReactivexDisposablesDisposable 1
#define INCLUDE_IoReactivexDisposablesDisposable 1
#include "io/reactivex/disposables/Disposable.h"

@class IoReactivexScheduler_Worker;
@protocol IoReactivexFunctionsFunction;

@interface IoReactivexInternalSchedulersSchedulerWhen : IoReactivexScheduler < IoReactivexDisposablesDisposable >

#pragma mark Public

- (instancetype)initWithIoReactivexFunctionsFunction:(id<IoReactivexFunctionsFunction>)combine
                            withIoReactivexScheduler:(IoReactivexScheduler *)actualScheduler;

- (IoReactivexScheduler_Worker *)createWorker;

- (void)dispose;

- (jboolean)isDisposed;

@end

J2OBJC_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen)

inline id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_get_SUBSCRIBED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_SUBSCRIBED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersSchedulerWhen, SUBSCRIBED, id<IoReactivexDisposablesDisposable>)

inline id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_get_DISPOSED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<IoReactivexDisposablesDisposable> IoReactivexInternalSchedulersSchedulerWhen_DISPOSED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(IoReactivexInternalSchedulersSchedulerWhen, DISPOSED, id<IoReactivexDisposablesDisposable>)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(IoReactivexInternalSchedulersSchedulerWhen *self, id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen *new_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen *create_IoReactivexInternalSchedulersSchedulerWhen_initWithIoReactivexFunctionsFunction_withIoReactivexScheduler_(id<IoReactivexFunctionsFunction> combine, IoReactivexScheduler *actualScheduler);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction))
#define IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_

#define RESTRICT_JavaUtilConcurrentAtomicAtomicReference 1
#define INCLUDE_JavaUtilConcurrentAtomicAtomicReference 1
#include "java/util/concurrent/atomic/AtomicReference.h"

#define RESTRICT_IoReactivexDisposablesDisposable 1
#define INCLUDE_IoReactivexDisposablesDisposable 1
#include "io/reactivex/disposables/Disposable.h"

@class IoReactivexScheduler_Worker;
@protocol IoReactivexCompletableObserver;

@interface IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction : JavaUtilConcurrentAtomicAtomicReference < IoReactivexDisposablesDisposable >

#pragma mark Public

- (void)dispose;

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

- (jboolean)isDisposed;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)init;

- (void)callWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
         withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction_init(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction *self);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction))
#define IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_

@class IoReactivexScheduler_Worker;
@protocol IoReactivexCompletableObserver;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;

@interface IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction : IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

#pragma mark Public

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *self, id<JavaLangRunnable> action);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *new_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction *create_IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction_initWithJavaLangRunnable_(id<JavaLangRunnable> action);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_ImmediateAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction))
#define IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_

@class IoReactivexScheduler_Worker;
@class JavaUtilConcurrentTimeUnit;
@protocol IoReactivexCompletableObserver;
@protocol IoReactivexDisposablesDisposable;
@protocol JavaLangRunnable;

@interface IoReactivexInternalSchedulersSchedulerWhen_DelayedAction : IoReactivexInternalSchedulersSchedulerWhen_ScheduledAction

#pragma mark Public

- (id<IoReactivexDisposablesDisposable>)get;

- (id<IoReactivexDisposablesDisposable>)getAndSetWithId:(id<IoReactivexDisposablesDisposable>)arg0;

#pragma mark Protected

- (id<IoReactivexDisposablesDisposable>)callActualWithIoReactivexScheduler_Worker:(IoReactivexScheduler_Worker *)actualWorker
                                               withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
                                withLong:(jlong)delayTime
          withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *self, id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *new_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_DelayedAction *create_IoReactivexInternalSchedulersSchedulerWhen_DelayedAction_initWithJavaLangRunnable_withLong_withJavaUtilConcurrentTimeUnit_(id<JavaLangRunnable> action, jlong delayTime, JavaUtilConcurrentTimeUnit *unit);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_DelayedAction)

#endif

#if !defined (IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_) && (INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen || defined(INCLUDE_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction))
#define IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_

#define RESTRICT_JavaLangRunnable 1
#define INCLUDE_JavaLangRunnable 1
#include "java/lang/Runnable.h"

@protocol IoReactivexCompletableObserver;

@interface IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction : NSObject < JavaLangRunnable >

#pragma mark Public

- (void)run;

#pragma mark Package-Private

- (instancetype)initWithJavaLangRunnable:(id<JavaLangRunnable>)action
      withIoReactivexCompletableObserver:(id<IoReactivexCompletableObserver>)actionCompletable;

@end

J2OBJC_EMPTY_STATIC_INIT(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)

FOUNDATION_EXPORT void IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *self, id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable);

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *new_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction *create_IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction_initWithJavaLangRunnable_withIoReactivexCompletableObserver_(id<JavaLangRunnable> action, id<IoReactivexCompletableObserver> actionCompletable);

J2OBJC_TYPE_LITERAL_HEADER(IoReactivexInternalSchedulersSchedulerWhen_OnCompletedAction)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_IoReactivexInternalSchedulersSchedulerWhen")
