//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/org/junit/internal/matchers/TypeSafeMatcher.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Error.h"
#include "java/lang/annotation/Annotation.h"
#include "java/lang/reflect/Method.h"
#include "org/hamcrest/BaseMatcher.h"
#include "org/junit/internal/MethodSorter.h"
#include "org/junit/internal/matchers/TypeSafeMatcher.h"

@interface OrgJunitInternalMatchersTypeSafeMatcher () {
 @public
  IOSClass *expectedType_;
}

+ (IOSClass *)findExpectedTypeWithIOSClass:(IOSClass *)fromClass;

+ (jboolean)isMatchesSafelyMethodWithJavaLangReflectMethod:(JavaLangReflectMethod *)method;

@end

J2OBJC_FIELD_SETTER(OrgJunitInternalMatchersTypeSafeMatcher, expectedType_, IOSClass *)

__attribute__((unused)) static IOSClass *OrgJunitInternalMatchersTypeSafeMatcher_findExpectedTypeWithIOSClass_(IOSClass *fromClass);

__attribute__((unused)) static jboolean OrgJunitInternalMatchersTypeSafeMatcher_isMatchesSafelyMethodWithJavaLangReflectMethod_(JavaLangReflectMethod *method);

__attribute__((unused)) static IOSObjectArray *OrgJunitInternalMatchersTypeSafeMatcher__Annotations$0();

@implementation OrgJunitInternalMatchersTypeSafeMatcher

- (jboolean)matchesSafelyWithId:(id)item {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgJunitInternalMatchersTypeSafeMatcher_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (IOSClass *)findExpectedTypeWithIOSClass:(IOSClass *)fromClass {
  return OrgJunitInternalMatchersTypeSafeMatcher_findExpectedTypeWithIOSClass_(fromClass);
}

+ (jboolean)isMatchesSafelyMethodWithJavaLangReflectMethod:(JavaLangReflectMethod *)method {
  return OrgJunitInternalMatchersTypeSafeMatcher_isMatchesSafelyMethodWithJavaLangReflectMethod_(method);
}

- (instancetype)initWithIOSClass:(IOSClass *)expectedType {
  OrgJunitInternalMatchersTypeSafeMatcher_initWithIOSClass_(self, expectedType);
  return self;
}

- (jboolean)matchesWithId:(id)item {
  return item != nil && [((IOSClass *) nil_chk(expectedType_)) isInstance:item] && [self matchesSafelyWithId:item];
}

- (void)dealloc {
  RELEASE_(expectedType_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "Z", 0x401, 0, 1, -1, 2, -1, -1 },
    { NULL, NULL, 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LIOSClass;", 0xa, 3, 4, -1, 5, -1, -1 },
    { NULL, "Z", 0xa, 6, 7, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 4, -1, 8, -1, -1 },
    { NULL, "Z", 0x11, 9, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(matchesSafelyWithId:);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(findExpectedTypeWithIOSClass:);
  methods[3].selector = @selector(isMatchesSafelyMethodWithJavaLangReflectMethod:);
  methods[4].selector = @selector(initWithIOSClass:);
  methods[5].selector = @selector(matchesWithId:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "expectedType_", "LIOSClass;", .constantValue.asLong = 0, 0x2, -1, -1, 10, -1 },
  };
  static const void *ptrTable[] = { "matchesSafely", "LNSObject;", "(TT;)Z", "findExpectedType", "LIOSClass;", "(Ljava/lang/Class<*>;)Ljava/lang/Class<*>;", "isMatchesSafelyMethod", "LJavaLangReflectMethod;", "(Ljava/lang/Class<TT;>;)V", "matches", "Ljava/lang/Class<*>;", "<T:Ljava/lang/Object;>Lorg/hamcrest/BaseMatcher<TT;>;", (void *)&OrgJunitInternalMatchersTypeSafeMatcher__Annotations$0 };
  static const J2ObjcClassInfo _OrgJunitInternalMatchersTypeSafeMatcher = { "TypeSafeMatcher", "org.junit.internal.matchers", ptrTable, methods, fields, 7, 0x401, 6, 1, -1, -1, -1, 11, 12 };
  return &_OrgJunitInternalMatchersTypeSafeMatcher;
}

@end

void OrgJunitInternalMatchersTypeSafeMatcher_init(OrgJunitInternalMatchersTypeSafeMatcher *self) {
  OrgHamcrestBaseMatcher_init(self);
  JreStrongAssign(&self->expectedType_, OrgJunitInternalMatchersTypeSafeMatcher_findExpectedTypeWithIOSClass_([self java_getClass]));
}

IOSClass *OrgJunitInternalMatchersTypeSafeMatcher_findExpectedTypeWithIOSClass_(IOSClass *fromClass) {
  OrgJunitInternalMatchersTypeSafeMatcher_initialize();
  for (IOSClass *c = fromClass; c != NSObject_class_(); c = [((IOSClass *) nil_chk(c)) getSuperclass]) {
    {
      IOSObjectArray *a__ = OrgJunitInternalMethodSorter_getDeclaredMethodsWithIOSClass_(c);
      JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      JavaLangReflectMethod * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        JavaLangReflectMethod *method = *b__++;
        if (OrgJunitInternalMatchersTypeSafeMatcher_isMatchesSafelyMethodWithJavaLangReflectMethod_(method)) {
          return IOSObjectArray_Get(nil_chk([((JavaLangReflectMethod *) nil_chk(method)) getParameterTypes]), 0);
        }
      }
    }
  }
  @throw create_JavaLangError_initWithNSString_(@"Cannot determine correct type for matchesSafely() method.");
}

jboolean OrgJunitInternalMatchersTypeSafeMatcher_isMatchesSafelyMethodWithJavaLangReflectMethod_(JavaLangReflectMethod *method) {
  OrgJunitInternalMatchersTypeSafeMatcher_initialize();
  return [((NSString *) nil_chk([((JavaLangReflectMethod *) nil_chk(method)) getName])) isEqual:@"matchesSafely"] && ((IOSObjectArray *) nil_chk([method getParameterTypes]))->size_ == 1 && ![method isSynthetic];
}

void OrgJunitInternalMatchersTypeSafeMatcher_initWithIOSClass_(OrgJunitInternalMatchersTypeSafeMatcher *self, IOSClass *expectedType) {
  OrgHamcrestBaseMatcher_init(self);
  JreStrongAssign(&self->expectedType_, expectedType);
}

IOSObjectArray *OrgJunitInternalMatchersTypeSafeMatcher__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgJunitInternalMatchersTypeSafeMatcher)
