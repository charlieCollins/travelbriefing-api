//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/okio/SegmentedByteString.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/OutputStream.h"
#include "java/lang/AssertionError.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/charset/Charset.h"
#include "java/util/Arrays.h"
#include "okio/Buffer.h"
#include "okio/ByteString.h"
#include "okio/Segment.h"
#include "okio/SegmentedByteString.h"
#include "okio/Util.h"

@interface OkioSegmentedByteString ()

- (jint)segmentWithInt:(jint)pos;

- (OkioByteString *)toByteString;

- (id)writeReplace;

@end

__attribute__((unused)) static jint OkioSegmentedByteString_segmentWithInt_(OkioSegmentedByteString *self, jint pos);

__attribute__((unused)) static OkioByteString *OkioSegmentedByteString_toByteString(OkioSegmentedByteString *self);

@implementation OkioSegmentedByteString

- (instancetype)initWithOkioBuffer:(OkioBuffer *)buffer
                           withInt:(jint)byteCount {
  OkioSegmentedByteString_initWithOkioBuffer_withInt_(self, buffer, byteCount);
  return self;
}

- (NSString *)utf8 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) utf8];
}

- (NSString *)stringWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) stringWithJavaNioCharsetCharset:charset];
}

- (NSString *)base64 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) base64];
}

- (NSString *)hex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) hex];
}

- (OkioByteString *)toAsciiLowercase {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) toAsciiLowercase];
}

- (OkioByteString *)toAsciiUppercase {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) toAsciiUppercase];
}

- (OkioByteString *)md5 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) md5];
}

- (OkioByteString *)sha1 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) sha1];
}

- (OkioByteString *)sha256 {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) sha256];
}

- (OkioByteString *)hmacSha1WithOkioByteString:(OkioByteString *)key {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) hmacSha1WithOkioByteString:key];
}

- (OkioByteString *)hmacSha256WithOkioByteString:(OkioByteString *)key {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) hmacSha256WithOkioByteString:key];
}

- (NSString *)base64Url {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) base64Url];
}

- (OkioByteString *)substringWithInt:(jint)beginIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) substringWithInt:beginIndex];
}

- (OkioByteString *)substringWithInt:(jint)beginIndex
                             withInt:(jint)endIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) substringWithInt:beginIndex withInt:endIndex];
}

- (jbyte)getByteWithInt:(jint)pos {
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1), pos, 1);
  jint segment = OkioSegmentedByteString_segmentWithInt_(self, pos);
  jint segmentOffset = segment == 0 ? 0 : IOSIntArray_Get(directory_, segment - 1);
  jint segmentPos = IOSIntArray_Get(directory_, segment + segments_->size_);
  return IOSByteArray_Get(nil_chk(IOSObjectArray_Get(segments_, segment)), pos - segmentOffset + segmentPos);
}

- (jint)segmentWithInt:(jint)pos {
  return OkioSegmentedByteString_segmentWithInt_(self, pos);
}

- (jint)size {
  return IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1);
}

- (IOSByteArray *)toByteArray {
  IOSByteArray *result = [IOSByteArray arrayWithLength:IOSIntArray_Get(nil_chk(directory_), ((IOSObjectArray *) nil_chk(segments_))->size_ - 1)];
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = segments_->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(directory_, segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(IOSObjectArray_Get(segments_, s), segmentPos, result, segmentOffset, nextSegmentOffset - segmentOffset);
    segmentOffset = nextSegmentOffset;
  }
  return result;
}

- (JavaNioByteBuffer *)asByteBuffer {
  return [((JavaNioByteBuffer *) nil_chk(JavaNioByteBuffer_wrapWithByteArray_([self toByteArray]))) asReadOnlyBuffer];
}

- (void)writeWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (outArg == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"out == null");
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    [outArg writeWithByteArray:IOSObjectArray_Get(segments_, s) withInt:segmentPos withInt:nextSegmentOffset - segmentOffset];
    segmentOffset = nextSegmentOffset;
  }
}

- (void)writeWithOkioBuffer:(OkioBuffer *)buffer {
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    OkioSegment *segment = create_OkioSegment_initWithByteArray_withInt_withInt_(IOSObjectArray_Get(segments_, s), segmentPos, segmentPos + nextSegmentOffset - segmentOffset);
    if (((OkioBuffer *) nil_chk(buffer))->head_ == nil) {
      JreStrongAssign(&buffer->head_, JreStrongAssign(&segment->next_, JreStrongAssign(&segment->prev_, segment)));
    }
    else {
      [((OkioSegment *) nil_chk(buffer->head_->prev_)) pushWithOkioSegment:segment];
    }
    segmentOffset = nextSegmentOffset;
  }
  ((OkioBuffer *) nil_chk(buffer))->size_ += segmentOffset;
}

- (jboolean)rangeEqualsWithInt:(jint)offset
            withOkioByteString:(OkioByteString *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount {
  if (offset < 0 || offset > [self size] - byteCount) return false;
  for (jint s = OkioSegmentedByteString_segmentWithInt_(self, offset); byteCount > 0; s++) {
    jint segmentOffset = s == 0 ? 0 : IOSIntArray_Get(nil_chk(directory_), s - 1);
    jint segmentSize = IOSIntArray_Get(nil_chk(directory_), s) - segmentOffset;
    jint stepSize = JavaLangMath_minWithInt_withInt_(byteCount, segmentOffset + segmentSize - offset);
    jint segmentPos = IOSIntArray_Get(directory_, ((IOSObjectArray *) nil_chk(segments_))->size_ + s);
    jint arrayOffset = offset - segmentOffset + segmentPos;
    if (![((OkioByteString *) nil_chk(other)) rangeEqualsWithInt:otherOffset withByteArray:IOSObjectArray_Get(segments_, s) withInt:arrayOffset withInt:stepSize]) return false;
    offset += stepSize;
    otherOffset += stepSize;
    byteCount -= stepSize;
  }
  return true;
}

- (jboolean)rangeEqualsWithInt:(jint)offset
                 withByteArray:(IOSByteArray *)other
                       withInt:(jint)otherOffset
                       withInt:(jint)byteCount {
  if (offset < 0 || offset > [self size] - byteCount || otherOffset < 0 || otherOffset > ((IOSByteArray *) nil_chk(other))->size_ - byteCount) {
    return false;
  }
  for (jint s = OkioSegmentedByteString_segmentWithInt_(self, offset); byteCount > 0; s++) {
    jint segmentOffset = s == 0 ? 0 : IOSIntArray_Get(nil_chk(directory_), s - 1);
    jint segmentSize = IOSIntArray_Get(nil_chk(directory_), s) - segmentOffset;
    jint stepSize = JavaLangMath_minWithInt_withInt_(byteCount, segmentOffset + segmentSize - offset);
    jint segmentPos = IOSIntArray_Get(directory_, ((IOSObjectArray *) nil_chk(segments_))->size_ + s);
    jint arrayOffset = offset - segmentOffset + segmentPos;
    if (!OkioUtil_arrayRangeEqualsWithByteArray_withInt_withByteArray_withInt_withInt_(IOSObjectArray_Get(segments_, s), arrayOffset, other, otherOffset, stepSize)) return false;
    offset += stepSize;
    otherOffset += stepSize;
    byteCount -= stepSize;
  }
  return true;
}

- (jint)indexOfWithByteArray:(IOSByteArray *)other
                     withInt:(jint)fromIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) indexOfWithByteArray:other withInt:fromIndex];
}

- (jint)lastIndexOfWithByteArray:(IOSByteArray *)other
                         withInt:(jint)fromIndex {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) lastIndexOfWithByteArray:other withInt:fromIndex];
}

- (OkioByteString *)toByteString {
  return OkioSegmentedByteString_toByteString(self);
}

- (IOSByteArray *)internalArray {
  return [self toByteArray];
}

- (jboolean)isEqual:(id)o {
  if (o == self) return true;
  return [o isKindOfClass:[OkioByteString class]] && [((OkioByteString *) nil_chk(((OkioByteString *) cast_chk(o, [OkioByteString class])))) size] == [self size] && [self rangeEqualsWithInt:0 withOkioByteString:((OkioByteString *) cast_chk(o, [OkioByteString class])) withInt:0 withInt:[self size]];
}

- (NSUInteger)hash {
  jint result = hashCode_;
  if (result != 0) return result;
  result = 1;
  jint segmentOffset = 0;
  for (jint s = 0, segmentCount = ((IOSObjectArray *) nil_chk(segments_))->size_; s < segmentCount; s++) {
    IOSByteArray *segment = IOSObjectArray_Get(segments_, s);
    jint segmentPos = IOSIntArray_Get(nil_chk(directory_), segmentCount + s);
    jint nextSegmentOffset = IOSIntArray_Get(directory_, s);
    jint segmentSize = nextSegmentOffset - segmentOffset;
    for (jint i = segmentPos, limit = segmentPos + segmentSize; i < limit; i++) {
      result = (31 * result) + IOSByteArray_Get(nil_chk(segment), i);
    }
    segmentOffset = nextSegmentOffset;
  }
  return (hashCode_ = result);
}

- (NSString *)description {
  return [((OkioByteString *) nil_chk(OkioSegmentedByteString_toByteString(self))) description];
}

- (id)writeReplace {
  return OkioSegmentedByteString_toByteString(self);
}

- (void)dealloc {
  RELEASE_(segments_);
  RELEASE_(directory_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, 5, 4, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x1, 6, 8, -1, -1, -1, -1 },
    { NULL, "B", 0x1, 9, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 10, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, 13, -1, -1, -1 },
    { NULL, "V", 0x0, 11, 14, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 15, 17, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 20, 19, -1, -1, -1, -1 },
    { NULL, "LOkioByteString;", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 21, 22, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 23, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 24, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithOkioBuffer:withInt:);
  methods[1].selector = @selector(utf8);
  methods[2].selector = @selector(stringWithJavaNioCharsetCharset:);
  methods[3].selector = @selector(base64);
  methods[4].selector = @selector(hex);
  methods[5].selector = @selector(toAsciiLowercase);
  methods[6].selector = @selector(toAsciiUppercase);
  methods[7].selector = @selector(md5);
  methods[8].selector = @selector(sha1);
  methods[9].selector = @selector(sha256);
  methods[10].selector = @selector(hmacSha1WithOkioByteString:);
  methods[11].selector = @selector(hmacSha256WithOkioByteString:);
  methods[12].selector = @selector(base64Url);
  methods[13].selector = @selector(substringWithInt:);
  methods[14].selector = @selector(substringWithInt:withInt:);
  methods[15].selector = @selector(getByteWithInt:);
  methods[16].selector = @selector(segmentWithInt:);
  methods[17].selector = @selector(size);
  methods[18].selector = @selector(toByteArray);
  methods[19].selector = @selector(asByteBuffer);
  methods[20].selector = @selector(writeWithJavaIoOutputStream:);
  methods[21].selector = @selector(writeWithOkioBuffer:);
  methods[22].selector = @selector(rangeEqualsWithInt:withOkioByteString:withInt:withInt:);
  methods[23].selector = @selector(rangeEqualsWithInt:withByteArray:withInt:withInt:);
  methods[24].selector = @selector(indexOfWithByteArray:withInt:);
  methods[25].selector = @selector(lastIndexOfWithByteArray:withInt:);
  methods[26].selector = @selector(toByteString);
  methods[27].selector = @selector(internalArray);
  methods[28].selector = @selector(isEqual:);
  methods[29].selector = @selector(hash);
  methods[30].selector = @selector(description);
  methods[31].selector = @selector(writeReplace);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "segments_", "[[B", .constantValue.asLong = 0, 0x90, -1, -1, -1, -1 },
    { "directory_", "[I", .constantValue.asLong = 0, 0x90, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOkioBuffer;I", "string", "LJavaNioCharsetCharset;", "hmacSha1", "LOkioByteString;", "hmacSha256", "substring", "I", "II", "getByte", "segment", "write", "LJavaIoOutputStream;", "LJavaIoIOException;", "LOkioBuffer;", "rangeEquals", "ILOkioByteString;II", "I[BII", "indexOf", "[BI", "lastIndexOf", "equals", "LNSObject;", "hashCode", "toString" };
  static const J2ObjcClassInfo _OkioSegmentedByteString = { "SegmentedByteString", "okio", ptrTable, methods, fields, 7, 0x10, 32, 2, -1, -1, -1, -1, -1 };
  return &_OkioSegmentedByteString;
}

@end

void OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioSegmentedByteString *self, OkioBuffer *buffer, jint byteCount) {
  OkioByteString_initWithByteArray_(self, nil);
  OkioUtil_checkOffsetAndCountWithLong_withLong_withLong_(((OkioBuffer *) nil_chk(buffer))->size_, 0, byteCount);
  jint offset = 0;
  jint segmentCount = 0;
  for (OkioSegment *s = buffer->head_; offset < byteCount; s = s->next_) {
    if (((OkioSegment *) nil_chk(s))->limit_ == s->pos_) {
      @throw create_JavaLangAssertionError_initWithId_(@"s.limit == s.pos");
    }
    offset += s->limit_ - s->pos_;
    segmentCount++;
  }
  JreStrongAssignAndConsume(&self->segments_, [IOSObjectArray newArrayWithLength:segmentCount type:IOSClass_byteArray(1)]);
  JreStrongAssignAndConsume(&self->directory_, [IOSIntArray newArrayWithLength:segmentCount * 2]);
  offset = 0;
  segmentCount = 0;
  for (OkioSegment *s = buffer->head_; offset < byteCount; s = s->next_) {
    IOSObjectArray_Set(self->segments_, segmentCount, ((OkioSegment *) nil_chk(s))->data_);
    offset += s->limit_ - s->pos_;
    if (offset > byteCount) {
      offset = byteCount;
    }
    *IOSIntArray_GetRef(self->directory_, segmentCount) = offset;
    *IOSIntArray_GetRef(self->directory_, segmentCount + self->segments_->size_) = s->pos_;
    s->shared_ = true;
    segmentCount++;
  }
}

OkioSegmentedByteString *new_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount) {
  J2OBJC_NEW_IMPL(OkioSegmentedByteString, initWithOkioBuffer_withInt_, buffer, byteCount)
}

OkioSegmentedByteString *create_OkioSegmentedByteString_initWithOkioBuffer_withInt_(OkioBuffer *buffer, jint byteCount) {
  J2OBJC_CREATE_IMPL(OkioSegmentedByteString, initWithOkioBuffer_withInt_, buffer, byteCount)
}

jint OkioSegmentedByteString_segmentWithInt_(OkioSegmentedByteString *self, jint pos) {
  jint i = JavaUtilArrays_binarySearchWithIntArray_withInt_withInt_withInt_(self->directory_, 0, ((IOSObjectArray *) nil_chk(self->segments_))->size_, pos + 1);
  return i >= 0 ? i : ~i;
}

OkioByteString *OkioSegmentedByteString_toByteString(OkioSegmentedByteString *self) {
  return create_OkioByteString_initWithByteArray_([self toByteArray]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OkioSegmentedByteString)
