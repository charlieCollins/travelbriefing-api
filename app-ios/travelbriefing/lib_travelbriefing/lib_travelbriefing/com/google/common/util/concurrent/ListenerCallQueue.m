//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ../target/dependency/com/google/common/util/concurrent/ListenerCallQueue.java
//

#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "com/google/common/base/Preconditions.h"
#include "com/google/common/collect/Queues.h"
#include "com/google/common/util/concurrent/ListenerCallQueue.h"
#include "java/lang/Iterable.h"
#include "java/lang/RuntimeException.h"
#include "java/util/ArrayDeque.h"
#include "java/util/Queue.h"
#include "java/util/concurrent/Executor.h"
#include "java/util/logging/Level.h"
#include "java/util/logging/Logger.h"

@interface ComGoogleCommonUtilConcurrentListenerCallQueue () {
 @public
  id listener_;
  id<JavaUtilConcurrentExecutor> executor_;
  id<JavaUtilQueue> waitQueue_;
  jboolean isThreadScheduled_;
}

@end

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentListenerCallQueue, listener_, id)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentListenerCallQueue, executor_, id<JavaUtilConcurrentExecutor>)
J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentListenerCallQueue, waitQueue_, id<JavaUtilQueue>)

inline JavaUtilLoggingLogger *ComGoogleCommonUtilConcurrentListenerCallQueue_get_logger();
static JavaUtilLoggingLogger *ComGoogleCommonUtilConcurrentListenerCallQueue_logger;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComGoogleCommonUtilConcurrentListenerCallQueue, logger, JavaUtilLoggingLogger *)

@interface ComGoogleCommonUtilConcurrentListenerCallQueue_Callback () {
 @public
  NSString *methodCall_;
}

@end

J2OBJC_FIELD_SETTER(ComGoogleCommonUtilConcurrentListenerCallQueue_Callback, methodCall_, NSString *)

J2OBJC_INITIALIZED_DEFN(ComGoogleCommonUtilConcurrentListenerCallQueue)

@implementation ComGoogleCommonUtilConcurrentListenerCallQueue

- (instancetype)initWithId:(id)listener
withJavaUtilConcurrentExecutor:(id<JavaUtilConcurrentExecutor>)executor {
  ComGoogleCommonUtilConcurrentListenerCallQueue_initWithId_withJavaUtilConcurrentExecutor_(self, listener, executor);
  return self;
}

- (void)addWithComGoogleCommonUtilConcurrentListenerCallQueue_Callback:(ComGoogleCommonUtilConcurrentListenerCallQueue_Callback *)callback {
  @synchronized(self) {
    [((id<JavaUtilQueue>) nil_chk(waitQueue_)) addWithId:callback];
  }
}

- (void)execute {
  jboolean scheduleTaskRunner = false;
  @synchronized(self) {
    if (!isThreadScheduled_) {
      isThreadScheduled_ = true;
      scheduleTaskRunner = true;
    }
  }
  if (scheduleTaskRunner) {
    @try {
      [((id<JavaUtilConcurrentExecutor>) nil_chk(executor_)) executeWithJavaLangRunnable:self];
    }
    @catch (JavaLangRuntimeException *e) {
      @synchronized(self) {
        isThreadScheduled_ = false;
      }
      [((JavaUtilLoggingLogger *) nil_chk(ComGoogleCommonUtilConcurrentListenerCallQueue_logger)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, SEVERE) withNSString:JreStrcat("$@$@", @"Exception while running callbacks for ", listener_, @" on ", executor_) withNSException:e];
      @throw e;
    }
  }
}

- (void)run {
  jboolean stillRunning = true;
  @try {
    while (true) {
      ComGoogleCommonUtilConcurrentListenerCallQueue_Callback *nextToRun;
      @synchronized(self) {
        ComGoogleCommonBasePreconditions_checkStateWithBoolean_(isThreadScheduled_);
        nextToRun = [((id<JavaUtilQueue>) nil_chk(waitQueue_)) poll];
        if (nextToRun == nil) {
          isThreadScheduled_ = false;
          stillRunning = false;
          break;
        }
      }
      @try {
        [nextToRun callWithId:listener_];
      }
      @catch (JavaLangRuntimeException *e) {
        [((JavaUtilLoggingLogger *) nil_chk(ComGoogleCommonUtilConcurrentListenerCallQueue_logger)) logWithJavaUtilLoggingLevel:JreLoadStatic(JavaUtilLoggingLevel, SEVERE) withNSString:JreStrcat("$@C$", @"Exception while executing callback: ", listener_, '.', nextToRun->methodCall_) withNSException:e];
      }
    }
  }
  @finally {
    if (stillRunning) {
      @synchronized(self) {
        isThreadScheduled_ = false;
      }
    }
  }
}

- (void)dealloc {
  RELEASE_(listener_);
  RELEASE_(executor_);
  RELEASE_(waitQueue_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, 1, -1, -1 },
    { NULL, "V", 0x20, 2, 3, -1, 4, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithId:withJavaUtilConcurrentExecutor:);
  methods[1].selector = @selector(addWithComGoogleCommonUtilConcurrentListenerCallQueue_Callback:);
  methods[2].selector = @selector(execute);
  methods[3].selector = @selector(run);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "logger", "LJavaUtilLoggingLogger;", .constantValue.asLong = 0, 0x1a, -1, 5, -1, -1 },
    { "listener_", "LNSObject;", .constantValue.asLong = 0, 0x12, -1, -1, 6, -1 },
    { "executor_", "LJavaUtilConcurrentExecutor;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "waitQueue_", "LJavaUtilQueue;", .constantValue.asLong = 0, 0x12, -1, -1, 7, -1 },
    { "isThreadScheduled_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSObject;LJavaUtilConcurrentExecutor;", "(TL;Ljava/util/concurrent/Executor;)V", "add", "LComGoogleCommonUtilConcurrentListenerCallQueue_Callback;", "(Lcom/google/common/util/concurrent/ListenerCallQueue$Callback<TL;>;)V", &ComGoogleCommonUtilConcurrentListenerCallQueue_logger, "TL;", "Ljava/util/Queue<Lcom/google/common/util/concurrent/ListenerCallQueue$Callback<TL;>;>;", "<L:Ljava/lang/Object;>Ljava/lang/Object;Ljava/lang/Runnable;" };
  static const J2ObjcClassInfo _ComGoogleCommonUtilConcurrentListenerCallQueue = { "ListenerCallQueue", "com.google.common.util.concurrent", ptrTable, methods, fields, 7, 0x10, 4, 5, -1, 3, -1, 8, -1 };
  return &_ComGoogleCommonUtilConcurrentListenerCallQueue;
}

+ (void)initialize {
  if (self == [ComGoogleCommonUtilConcurrentListenerCallQueue class]) {
    JreStrongAssign(&ComGoogleCommonUtilConcurrentListenerCallQueue_logger, JavaUtilLoggingLogger_getLoggerWithNSString_([ComGoogleCommonUtilConcurrentListenerCallQueue_class_() getName]));
    J2OBJC_SET_INITIALIZED(ComGoogleCommonUtilConcurrentListenerCallQueue)
  }
}

@end

void ComGoogleCommonUtilConcurrentListenerCallQueue_initWithId_withJavaUtilConcurrentExecutor_(ComGoogleCommonUtilConcurrentListenerCallQueue *self, id listener, id<JavaUtilConcurrentExecutor> executor) {
  NSObject_init(self);
  JreStrongAssign(&self->waitQueue_, ComGoogleCommonCollectQueues_newArrayDeque());
  JreStrongAssign(&self->listener_, ComGoogleCommonBasePreconditions_checkNotNullWithId_(listener));
  JreStrongAssign(&self->executor_, ComGoogleCommonBasePreconditions_checkNotNullWithId_(executor));
}

ComGoogleCommonUtilConcurrentListenerCallQueue *new_ComGoogleCommonUtilConcurrentListenerCallQueue_initWithId_withJavaUtilConcurrentExecutor_(id listener, id<JavaUtilConcurrentExecutor> executor) {
  J2OBJC_NEW_IMPL(ComGoogleCommonUtilConcurrentListenerCallQueue, initWithId_withJavaUtilConcurrentExecutor_, listener, executor)
}

ComGoogleCommonUtilConcurrentListenerCallQueue *create_ComGoogleCommonUtilConcurrentListenerCallQueue_initWithId_withJavaUtilConcurrentExecutor_(id listener, id<JavaUtilConcurrentExecutor> executor) {
  J2OBJC_CREATE_IMPL(ComGoogleCommonUtilConcurrentListenerCallQueue, initWithId_withJavaUtilConcurrentExecutor_, listener, executor)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComGoogleCommonUtilConcurrentListenerCallQueue)

@implementation ComGoogleCommonUtilConcurrentListenerCallQueue_Callback

- (instancetype)initWithNSString:(NSString *)methodCall {
  ComGoogleCommonUtilConcurrentListenerCallQueue_Callback_initWithNSString_(self, methodCall);
  return self;
}

- (void)callWithId:(id)listener {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)enqueueOnWithJavaLangIterable:(id<JavaLangIterable>)queues {
  for (ComGoogleCommonUtilConcurrentListenerCallQueue * __strong queue in nil_chk(queues)) {
    [((ComGoogleCommonUtilConcurrentListenerCallQueue *) nil_chk(queue)) addWithComGoogleCommonUtilConcurrentListenerCallQueue_Callback:self];
  }
}

- (void)dealloc {
  RELEASE_(methodCall_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x400, 1, 2, -1, 3, -1, -1 },
    { NULL, "V", 0x0, 4, 5, -1, 6, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithNSString:);
  methods[1].selector = @selector(callWithId:);
  methods[2].selector = @selector(enqueueOnWithJavaLangIterable:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "methodCall_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;", "call", "LNSObject;", "(TL;)V", "enqueueOn", "LJavaLangIterable;", "(Ljava/lang/Iterable<Lcom/google/common/util/concurrent/ListenerCallQueue<TL;>;>;)V", "LComGoogleCommonUtilConcurrentListenerCallQueue;", "<L:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _ComGoogleCommonUtilConcurrentListenerCallQueue_Callback = { "Callback", "com.google.common.util.concurrent", ptrTable, methods, fields, 7, 0x408, 3, 1, 7, -1, -1, 8, -1 };
  return &_ComGoogleCommonUtilConcurrentListenerCallQueue_Callback;
}

@end

void ComGoogleCommonUtilConcurrentListenerCallQueue_Callback_initWithNSString_(ComGoogleCommonUtilConcurrentListenerCallQueue_Callback *self, NSString *methodCall) {
  NSObject_init(self);
  JreStrongAssign(&self->methodCall_, methodCall);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComGoogleCommonUtilConcurrentListenerCallQueue_Callback)
